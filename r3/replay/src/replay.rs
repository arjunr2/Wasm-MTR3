//! Binary crate for generating replay Wasm modules given a Trace and the
//! original module that was recorded.

#![feature(binary_heap_into_iter_sorted)]

use clap::Parser;
use log::info;
use sha256::digest;
use std::error::Error;
use std::fs;

use common::trace::*;

pub mod parser;
use parser::{construct_replay_ops, dump_replay_ops, reorder_replay_ops};

pub mod generator;
use generator::generate_replay_file;

pub mod structs;

/// Command-Line Arguments
#[derive(Parser, Debug)]
#[command(version, about, long_about=None)]
struct CLI {
    /// Trace output file generated by `record`
    #[arg(short, long, default_value_t = String::from("trace.r3"))]
    tracefile: String,

    /// Output (modified) Wasm replay file
    #[arg(short, long, default_value_t = String::from("replay.wasm"))]
    outfile: String,

    /// Enable debug calls within generated replay file
    #[arg(short, long)]
    debug: bool,

    /// Transformed replay operations output file
    #[arg(short = 'f', long)]
    opsfile: Option<String>,

    /// Original (unmodified) Wasm file
    #[arg(short, long)]
    wasmfile: String,
}

impl CLI {
    /// Print the CLI configuration
    fn print(&self) {
        info!("Wasmfile: {:?}", self.wasmfile);
        info!("Tracefile: {:?}", self.tracefile);
        info!("Generate Debug: {:?}", self.debug);
        info!("Opsfile: {:?}", self.opsfile);
        info!("Outfile: {:?}", self.outfile);
    }
}

/// Entrypoint for `replay`
fn main() -> Result<(), Box<dyn Error>> {
    env_logger::builder().format_timestamp_millis().init();
    let cli = CLI::parse();
    cli.print();

    // Read wasm file, compute its digest
    let wasmbin = fs::read(cli.wasmfile.as_str())?;
    let sha256_wasm = digest(&wasmbin);

    // Read trace file and deserialize
    let tracebin = fs::read(cli.tracefile.as_str())?;
    let deserialized = TraceData::deserialize(&tracebin, Some(sha256_wasm.as_str()));

    let mut replay_ops = construct_replay_ops(&deserialized.trace);
    // Dump ops before reordering since it's already ordered by sync_ids
    if let Some(opsfile) = cli.opsfile {
        dump_replay_ops(&replay_ops, opsfile.as_str()).unwrap();
    }
    // Reorder replay ops to order by tids first and then sync_ids
    reorder_replay_ops(&mut replay_ops);

    generate_replay_file(&replay_ops, &wasmbin, &cli.outfile, cli.debug)?;

    Ok(())
}
